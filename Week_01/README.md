总结
===
刷题技巧
---
*做题不死磕，注意保证学习效率<br>
*五毒神掌，一定要过遍数 <br>
*看题解掌握多种解题思路，归纳总结每种方法<br>

学习方法
---
*系统性学习，学到的知识点做思维导图，建立知识网络<br>
*根据题型去做练习，熟练掌握各种题型，要做到每次做新题能分析出可用的所有方法<br>
*坚持练习，数据结构和算法是所有技术的基础<br>

分析 Queue 和 Priority Queue 的源码
---
# Queue
`Queue`是队列，是一种先进先出的数据结构。<br>

## 内部数据结构<br>

`boolean add(E e)`
    在队列头部增加一个元素，如果容量已满，则抛出异常，成功则返回true<br>

`boolean offer(E e)`
    在队列头部增加一个元素，如果容量已满，则返回false，成功加入，返回true;<br>

`E remove()`
    将队列头部元素移出队列并返回，如果队列为空，则抛出异常。<br>

`E poll()`
   将队列头部元素移出队列并返回，如果队列为空，返回null<br>

`E element()`
     返回队列头部节点，但不移除队列头节点，如果队列为空，则抛出异常。<br>

`E peek()`
     返回队列头部节点，但不移除队列头节点，如果队列为空，返回null。<br>
     
# PriorityQueue
`PriorityQueue`是优先级队列，PriorityQueue是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。<br>

`PriorityQueue的实现使用了最小堆，堆的数据结构如下特点：<br>
*一颗完全二叉树
*只允许最后两层的节点的度小于2
*如果度小于2的节点，如果有子节点，那一定是左子树
*最小堆的父节点比子节点都小
*最大堆，父节点比子节点都大，但左右节点的大小并没有要求。`

## PrioriyQueue内部数据结构

`boolean add(E e) & boolean offer(E e)`
add(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于PriorityQueue这两个方法其实没什么差别。新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。<br>

`E remove() & E poll()`
remove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。<br>

`E element() & E peek()`
element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。<br>
